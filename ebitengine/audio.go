// (c) 2022 Jacek Olszak
// This code is licensed under MIT license (see LICENSE for details)

package ebitengine

import (
	"github.com/hajimehoshi/ebiten/v2/audio"

	"github.com/elgopher/pi"
)

const (
	audioSampleRate = 44100
	channelCount    = 2 // stereo
	uint16Bytes     = 2
	sampleLen       = channelCount * uint16Bytes
)

// AudioStream is an abstraction used by ebitengine back-end to consume audio stream generated by the game. The stream
// will be played back to the user. By default, [pi.AudioSystem] is used. Game developers could use a different audio
// system though. In such case they could set the AudioStream variable to their own implementation.
var AudioStream interface {
	// Read reads generated audio into p buffer.
	//
	// The audio stream is mono (one channel). Each sample is a single float64 from range [-1,1].
	// Values outside the range will be clamped before playing back to the user. Sample rate is 44100.
	//
	// See [io.Reader] for documentation how to implement this method.
	// When error is returned then game stops with the error.
	Read(p []float64) (n int, err error)
}

func startAudio() (stop func(), _ error) {
	if AudioStream == nil {
		AudioStream = pi.Audio()
	}

	audioCtx := audio.NewContext(audioSampleRate)
	player, err := audioCtx.NewPlayer(&audioStreamReader{})
	if err != nil {
		return func() {}, err
	}
	player.Play()

	return func() {
		_ = player.Close()
	}, nil
}

// audioStreamReader reads floats from AudioStream and convert them to Ebitengine format -
// linear PCM (signed 16bits little endian, 2 channel stereo).
type audioStreamReader struct {
	singleSample   []byte    // singleSample in Ebitengine format - first two bytes left channel, next two bytes right
	remainingBytes int       // number of bytes from singleSample still not copied to p
	floatBuffer    []float64 // reused buffer to avoid allocation on each Read request
}

func (a *audioStreamReader) Read(p []byte) (int, error) {
	if len(p) == 0 {
		return 0, nil
	}

	if a.remainingBytes > 0 {
		n := copy(p, a.singleSample[sampleLen-a.remainingBytes:])
		a.remainingBytes = 0
		return n, nil
	}

	if a.singleSample == nil {
		a.singleSample = make([]byte, sampleLen)
	}

	samples := len(p) / sampleLen
	if len(p)%sampleLen != 0 {
		samples += 1
		a.remainingBytes = sampleLen - len(p)%sampleLen
	}

	a.ensureFloatBufferIsBigEnough(samples)

	bytesRead := 0

	n, err := AudioStream.Read(a.floatBuffer[:samples])
	for i := 0; i < n; i++ {
		floatSample := pi.Mid(a.floatBuffer[i], -1, 1)
		sample := int16(floatSample * 0x7FFF) // actually the full int16 range is -0x8000 to 0x7FFF (therefore -0x8000 will never be returned)

		a.singleSample[0] = byte(sample)
		a.singleSample[1] = byte(sample >> 8)
		copy(a.singleSample[2:], a.singleSample[:2]) // copy left to right channel

		copiedBytes := copy(p, a.singleSample)
		p = p[copiedBytes:]
		bytesRead += copiedBytes
	}

	return bytesRead, err
}

func (a *audioStreamReader) ensureFloatBufferIsBigEnough(size int) {
	if size > len(a.floatBuffer) {
		a.floatBuffer = make([]float64, size)
	}
}
